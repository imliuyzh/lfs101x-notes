# More on Bash Shell Scripting

## String Manipulation
A string variable contains a sequence of text characters. In most cases, we can use single square brackets ( `[]` ) instead of double (`[[]]`) in comparisons and logical tests, but the more modern doubled form helps avoid some errors, such as those that can arise when doing a comparison with empty strings and environment variables.

| Operator | Meaning |
| - | - |
| `[[ string1 > string2 ]]` <br> `[[ string1 < string2 ]]` | Compares the sorting order of `string1` and `string2` |
| `[[ string1 == string2 ]]` | Compares the characters in `string1` with the characters in `string2` |
| `myLen1=${#string1}` | Gets the length of `string1` in the variable `myLen1` |

## Parts of a String
At times, you may not need to compare or use an entire string. To extract the first n characters of a string, we can specify `${string:0:n}`. Here, 0 is the offset in the string where the extraction needs to start, and `n` is the number of characters to be extracted. To extract all characters in a string after a dot (`.`), use the following expression: `${string#*.}`.

## The `for` Loop
The `for` loop operates on each element of a list of items. The syntax for the `for` loop is:

```
for variable-name in list
do
    execute one iteration for each item in the list until the list is finished
done
```

In this case, `variable-name` and `list` are substituted by you as appropriate. As with other looping constructs, the statements that are repeated should be enclosed by `do` and `done`.

```bash
f() {
    local sum=0
    for j in {1..10..1}; do
        sum=$((sum+j))
    done
    echo "${sum}"
}
```

## The `while` Loop
The `while` loop repeats a set of statements as long as the control command returns true:

```
while condition is true
do
    Commands for execution
done
```

The set of commands that need to be repeated should be enclosed between `do` and `done`. Often, the condition is enclosed within square brackets (`[]`).

Notice the integer overflow below:

```bash
f() {
    local n=$1 factorial=1 j=1
    while [[ $j -le $n ]]; do
        factorial=$((factorial*j))
        j=$((j+1))
    done
    printf '(%d!) = %d\n' $n $factorial
}

f 6     # (6!) = 720
f 20    # (20!) = 2432902008176640000
f 21    # (21!) = -4249290049419214848
```

## The `until` Loop
The `until` loop repeats a set of statements as long as the control command is false:

```
until condition is false
do
    Commands for execution
done
```

Similar to the while loop, the set of commands that need to be repeated should be enclosed between `do` and `done`. You can use any command or operator as the condition.

Notice the integer overflow below:

```bash
f() {
    local n=$1 factorial=1 j=1
    until [[ $j -gt $n ]]; do
        factorial=$((factorial*j))
        j=$((j+1))
    done
    printf '(%d!) = %d\n' $n $factorial
}

f 7     # (7!) = 5040
f 20    # (20!) = 2432902008176640000
f 21    # (21!) = -4249290049419214848
```

## The `case` Statement
Here is the basic structure of the `case` statement:

```
case expression in
    pattern1) execute commands;;
    pattern2) execute commands;;
    pattern3) execute commands;;
    pattern4) execute commands;;
    *)        execute some default commands or nothing;;
esac
```

Note that as soon as the expression matches a pattern successfully, the execution path exits; i.e., the further tests are neither executed nor evaluated. If none of the tests return success, the final choice will execute, which can be to do nothing.

```bash
f() {
    read input
    case "$input" in
        "1") echo "11";;
        "2") echo "22";;
        "3") echo "33";;
        *) echo "Only accepts 1, 2, or 3";;
    esac
}
```

## Arrays
Arrays are variables that hold more than one value at a time. 

To create and access individual elements of the array:

```bash
# The first day of the week is Monday and the last day of the week is Sunday.
days=(Sun Mon Tue Wed Thu Fri Sat)
echo "The first day of the week is ${days[1]}day and the last day of the week is ${days[0]}day."
```

To print all the values of an array, use the `"array[@]"` notation. Similarly, arrays use the `${#array[@]}` notation to get the total number of elements in the array. Note it is possible to assign values to a specific index.

```bash
# There are 7 days in a week:
# Sun
# Mon
# Tue
# Wed
# Thu
# Fri
# Sat
days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)
echo "There are ${#days[@]} days in a week:"
for day in "${days[@]}"; do
    echo $day
done
```

To append new elements to the array:

```bash
# 1 2 3 4 5
# 1 2 3 4 5 6 7 8 9 10
numbers=(1 2 3 4 5)
echo "${numbers[@]}"
numbers+=(6 7 8 9 10)
echo "${numbers[@]}"
```

## Random Numbers and Data
Random numbers can be generated by using the `$RANDOM` environment variable, which is derived from the Linux kernel's built-in random number generator, or by the OpenSSL library function, which uses the FIPS140 (Federal Information Processing Standard) algorithm to generate random numbers for encryption.

```bash
# 25303
# 21001
# 25501
# 12057
# 26193
c1=5
until [[ $c1 -le 0 ]]; do
    echo $RANDOM
    c1=$((c1-1))
done
```

### How the Kernel Generates Random Numbers
Some servers have hardware random number generators that take as input different types of noise signals, such as thermal noise and photoelectric effect. A transducer converts this noise into an electric signal, which is again converted into a digital number by an A-D converter. This number is considered random. However, most common computers do not contain such specialized hardware and, instead, rely on events created during booting to create the raw data needed.

Regardless of which of these two sources is used, the system maintains a so-called entropy pool of these digital numbers/random bits. Random numbers are created from this entropy pool.

The Linux kernel offers the `/dev/random` and `/dev/urandom` device nodes, which draw on the entropy pool to provide random numbers which are drawn from the estimated number of bits of noise in the entropy pool.

`/dev/random` is used where very high-quality randomness is required, such as a one-time pad or key generation, but it is relatively slow to provide values. `/dev/urandom` is faster and suitable (good enough) for most cryptographic purposes.

Furthermore, when the entropy pool is empty, `/dev/random` is blocked and does not generate any number until additional environmental noise is gathered, whereas `/dev/urandom` reuses the internal pool to produce more pseudo-random bits.

## Good Locations for Scripts
The `~/bin` directory is a good place to put scripts intended for personal use. If we write a script that everyone on a system can use, we generally put it in `/usr/local/bin`. Scripts intended for use by the system administrator are often located in `/usr/local/sbin`.
